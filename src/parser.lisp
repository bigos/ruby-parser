(in-package :ruby-parser)

(defmacro defparser (name &body body)
  (let ((options
          (iter (while (and (consp (car body))
                            (keywordp (caar body))))
                (collect (pop body)))))
    `(yacc:define-parser ,name
       ,@options
       ,@(iter (for (name . rhss) in body)
               (for new-rhss =
                    (iter (for i from 1)
                          (for rhs in rhss)
                          (if (and (consp rhs)
                                   (listp (car rhs)))
                              (let* ((body (cdr rhs))
                                     (args (iter (for i from 1 to (length (car rhs)))
                                                 (collect (intern (format nil "$~D" i)))))
                                     (action-name (alexandria:symbolicate name (format nil "-~D" i)))
                                     (action `(alexandria:named-lambda ,action-name ,args
                                                (declare (ignorable ,@args))
                                                ,@body)))
                                (collect `(,@(car rhs) ,action)))
                              (collect rhs))))
               (collect (cons name new-rhss))))))

(defun const-name-p (name)
  (and (stringp name)
       (plusp (length name))
       (upper-case-p (char name 0))))

(defun cvar-name-p (name)
  (and (stringp name)
       (>= (length name) 2)
       (char= (char name 0) #\@)
       (char= (char name 1) #\@)))

(defun ivar-name-p (name)
  (and (stringp name)
       (not (const-name-p name))
       (plusp (length name))
       (char= (char name 0) #\@)))

(defun gvar-name-p (name)
  (and (stringp name)
       (plusp (length name))
       (char= (char name 0) #\$)))

(defun yyerror (control-string &rest args)
  (apply #'error control-string args))

(defun backref-assign-error (backref)
  (declare (ignore backref)))

(defun new-logop (lhs op rhs)
  (multiple-value-ematch (values op lhs)
    ((:and (and-expr (lhs l) (rhs r) loc))
     (make-and-expr :lhs l :rhs (new-logop r op rhs) :loc loc))
    ((:and _)
     (make-and-expr :lhs lhs :rhs rhs))
    ((:or (or-expr (lhs l) (rhs r) loc))
     (make-or-expr :lhs l :rhs (new-logop r op rhs) :loc loc))
    ((:or _)
     (make-or-expr :lhs lhs :rhs rhs))))

(defun literal-concat (head tail)
  (multiple-value-ematch (values head tail)
    (((lit-expr (lit (string-lit (value head-value))) loc)
      (lit-expr (lit (string-lit (value tail-value)))))
     (make-lit-expr :lit (make-string-lit :value (append head-value tail-value)) :loc loc))))

(defun gettable (name &key loc)
  (match name
    ("nil"      (make-id-expr :id (make-pvar :name :nil) :loc loc))
    ("true"     (make-id-expr :id (make-pvar :name :true) :loc loc))
    ("false"    (make-id-expr :id (make-pvar :name :false) :loc loc))
    ("self"     (make-id-expr :id (make-pvar :name :self) :loc loc))
    ("__FILE__" (make-id-expr :id (make-pvar :name :__FILE__) :loc loc))
    ("__LINE__" (make-id-expr :id (make-pvar :name :__LINE__) :loc loc))
    (otherwise
     (cond ((cvar-name-p name)
            (make-id-expr :id (make-cvar :name (subseq name 2)) :loc loc))
           ((ivar-name-p name)
            (make-id-expr :id (make-ivar :name (subseq name 1)) :loc loc))
           ((ivar-name-p name)
            (make-id-expr :id (make-gvar :name (subseq name 1)) :loc loc))
           ((const-name-p name)
            (make-id-expr :id (make-const :cpath (make-cpath-name :string name))
                          :loc loc))
           (t
            (with-slots (env) *state*
              (case (env-find env name)
                (:lvar (make-id-expr :id (make-lvar :name name) :loc loc))
                (:dvar (make-id-expr :id (make-dvar :name name) :loc loc))
                (otherwise (make-call-expr :meth name :loc loc)))))))))

(defun new-assignable (name &key loc)
  (declare (ignore loc))
  (match name
    ((or "nil" "self" "true" "false"
         "__FILE__" "__LINE__")
     (error "Can't change the value of ~A" name))
    (otherwise
     (with-slots (env in-def in-single) *state*
       (unless (env-find env name)
         (env-add env name :lvar))
       (cond ((cvar-name-p name)
              (if (or (plusp in-def) (plusp in-single))
                  (make-lhs-id :id (make-cvar :name name))
                  (make-lhs-decl :id (make-cvar :name name))))
             ((ivar-name-p name)
              (make-lhs-id :id (make-ivar :name name)))
             ((gvar-name-p name)
              (make-lhs-id :id (make-gvar :name name)))
             ((const-name-p name)
              (make-lhs-id :id (make-const :cpath (make-cpath-name :string name))))
             (t
              (case (env-find env name)
                (:lvar (make-lhs-id :id (make-lvar :name name)))
                (:dvar
                 (unless (eq (env-find-in-current env name) :dvar)
                   (env-use env name))
                 (make-lhs-id :id (make-lvar :name name)))
                (otherwise
                 (make-lhs-id :id (make-lvar :name name))))))))))

(defun get-match-node (lhs rhs &key loc)
  (multiple-value-match (values lhs rhs)
    (((lit-expr (lit (regexp-lit))) _)
     (make-call-expr :recv lhs :meth "=~" :args (list (make-arg-value :expr rhs)) :loc loc))
    ((_ (lit-expr (lit (regexp-lit))))
     (make-call-expr :recv rhs :meth "=~" :args (list (make-arg-value :expr lhs)) :loc loc))
    ((_ _)
     (make-call-expr :recv lhs :meth "=~" :args (list (make-arg-value :expr rhs)) :loc loc))))

(defun new-aref (ary args &key loc)
  (match ary
    ((id-expr (id (pvar (name :self))))
     (make-call-expr :meth "[]" :args args :loc loc))
    (otherwise
     (make-call-expr :recv ary :meth "[]" :args args :loc loc))))

(defun new-op-asgn (lhs op arg &key loc)
  (let ((lhs (match op
               ("||" (make-lhs-or :lhs lhs))
               ("&&" (make-lhs-and :lhs lhs))
               (_    (make-lhs-op :lhs lhs :op op)))))
    (make-assign-expr :lhs lhs :rhs arg :kind :single :loc loc)))

;;; Parser

(defvar *state* nil)

(locally (declare #.standard-optimize-settings)
  (defparser *parser*
    (:start-symbol program)
    (:terminals #.*terminals*)
    (:precedence
     ((:right    :tBANG :tTILDE :tUPLUS)
      (:right    :tPOW)
      (:right    :tUMINUS-NUM :tUMINUS)
      (:left     :tSTAR2 :tDIVIDE :tPERCENT)
      (:left     :tPLUS :tMINUS)
      (:left     :tLSHFT :tRSHFT)
      (:left     :tAMPER2)
      (:left     :tPIPE :tCARET)
      (:left     :tGT :tGEQ :tLT :tLEQ)
      (:nonassoc :tCMP :tEQ :tEQQ :tNEQ :tMATCH :tNMATCH)
      (:left     :tANDOP)
      (:left     :tOROP)
      (:nonassoc :tDOT2 :tDOT3)
      (:right    :tEH :tCOLON)
      (:left     :kRESCUE-MOD)
      (:right    :tEQL :tOP-ASGN)
      (:nonassoc :kDEFINED)
      (:right    :kNOT)
      (:left     :kOR :kAND)
      (:nonassoc :kIF-MOD :kUNLESS-MOD :kWHILE-MOD :kUNTIL-MOD)
      (:nonassoc :tLBRACE-ARG)
      (:nonassoc :tLOWEST)))

    (program ((program-e1 compstmt) $2))

    (program-e1 (() (setf (slot-value *state* 'lex-state) :expr-beg)))

    (bodystmt ((compstmt opt-rescue opt-else opt-ensure)
               (make-body-stmt :body $1
                               :rescues $2
                               :else $3
                               :ensure $4)))

    (compstmt ((stmts opt-terms) $1))

    (stmts (() ())
           ((stmt) (list $1))
           ((stmts terms stmt) (append $1 (list $3)))
           ((error stmt) $2))

    (stmt ((:kALIAS fitem stmt-e1 fitem)
           (make-alias-stmt :new $2 :old $4 :loc $1))
          ((:kALIAS :tGVAR :tGVAR)
           (make-alias-stmt :new $2 :old $3 :loc $1))
          ((:kALIAS :tGVAR :tBACK-REF)
           (make-alias-stmt :new $2 :old $3 :loc $1))
          ((:kALIAS :tGVAR :tNTH-REF)
           (yyerror "can't make alias for the number variables"))
          ((:kUNDEF undef-list)
           (make-undef-stmt :list $2 :loc $1))
          ((stmt :kIF-MOD expr-value)
           (make-if-mod-stmt :stmt $1 :test $3 :loc $2))
          ((stmt :kUNLESS-MOD expr-value)
           (make-unless-mod-stmt :stmt $1 :test $3 :loc $2))
          ((stmt :kWHILE-MOD expr-value)
           (make-while-mod-stmt :stmt $1 :test $3 :loc $2))
          ((stmt :kUNTIL-MOD expr-value)
           (make-until-mod-stmt :stmt $1 :test $3 :loc $2))
          ((stmt :kRESCUE-MOD stmt)
           (make-rescue-mod-stmt :stmt $1 :else $3 :loc $2))
          ((:klBEGIN stmt-e2 :tLCURLY compstmt :tRCURLY)
           (make-pre-exec-stmt :body $4 :loc $1))
          ((:klEND :tLCURLY compstmt :tRCURLY)
           (if (or (plusp (slot-value *state* 'in-def))
                   (plusp (slot-value *state* 'in-single)))
               (yyerror "END in method; use at-exit")
               (make-post-exec-stmt :body $3 :loc $1)))
          ((lhs :tEQL command-call)
           (make-expr-stmt :expr (make-assign-expr :lhs $1 :rhs $3 :kind :single)))
          ((mlhs :tEQL command-call)
           (make-expr-stmt :expr (make-assign-expr :lhs (make-lhs-dest :list $1)
                                                   :rhs $3
                                                   :kind :multi
                                                   :loc $2)))
          ((var-lhs :tOP-ASGN command-call)
           (make-expr-stmt :expr (new-op-asgn $1 $2 $3)))
          ((primary-value |[| aref-args :tRBRACK :tOP-ASGN command-call)
           (make-expr-stmt :expr (new-op-asgn (make-lhs-aref :self $1 :args $3) $5 $6)))
          ((primary-value :tDOT :tIDENTIFIER :tOP-ASGN command-call)
           (make-expr-stmt :expr (new-op-asgn (make-lhs-attr :self $1 :meth (car $3)) $4 $5)))
          ((primary-value :tDOT :tCONSTANT :tOP-ASGN command-call)
           (make-expr-stmt :expr (new-op-asgn (make-lhs-attr :self $1 :meth (car $3)) $4 $5)))
          ((primary-value :tCOLON2 :tIDENTIFIER :tOP-ASGN command-call)
           (make-expr-stmt :expr (new-op-asgn (make-lhs-attr :self $1 :meth (car $3)) $4 $5)))
          ((backref :tOP-ASGN command-call)
           (backref-assign-error $1))
          ((lhs :tEQL mrhs)
           (make-expr-stmt :expr (make-assign-expr :lhs $1
                                                   :rhs (make-array-expr :args $3)
                                                   :kind :svalue)))
          ((mlhs :tEQL arg-value)
           (make-expr-stmt :expr (make-assign-expr :lhs (make-lhs-dest :list $1)
                                                   :rhs $3
                                                   :kind :multi)))
          ((mlhs :tEQL mrhs)
           (make-expr-stmt :expr (make-assign-expr :lhs (make-lhs-dest :list $1)
                                                   :rhs (make-array-expr :args $3)
                                                   :kind :multi)))
          ((expr) (make-expr-stmt :expr $1)))

    (stmt-e1 (() (setf (slot-value *state* 'lex-state) :expr-fname)))

    (stmt-e2 (() (if (or (plusp (slot-value *state* 'in-def))
                         (plusp (slot-value *state* 'in-single)))
                     (yyerror "BEGIN in method")
                     (env-extend (slot-value *state* 'env)))))

    (expr ((command-call) $1)
          ((expr :kAND expr)
           (new-logop $1 :and $3))
          ((expr :kOR expr)
           (new-logop $1 :or $3))
          ((:kNOT expr)
           (make-not-expr :expr $2 :loc $1))
          ((:tBANG command-call)
           (make-not-expr :expr $2 :loc $1))
          ((arg) $1))

    (expr-value ((expr) $1))

    (command-call ((command) $1)
                  ((block-command) $1)
                  ((:kRETURN call-args)
                   (make-return-expr :args $2 :loc $1))
                  ((:kBREAK call-args)
                   (make-break-expr :args $2 :loc $1))
                  ((:kNEXT call-args)
                   (make-next-expr :args $2 :loc $1)))

    (block-command ((block-call) $1)
                   ((block-call :tDOT operation2 command-args)
                    (make-call-expr :recv $1 :meth $3 :args $4))
                   ((block-call :tCOLON2 operation2 command-args)
                    (make-call-expr :recv $1 :meth $3 :args $4)))

    (cmd-brace-block ((:tLBRACE-ARG cmd-brace-block-e1 opt-block-var compstmt :tRCURLY)
                      (let ((block (make-blk :vars $3 :body $4)))
                        (env-unextend (slot-value *state* 'env))
                        block)))

    (cmd-brace-block-e1 (()
                         (env-extend (slot-value *state* 'env) t)
                         ()))

    (command ((operation command-args #|%prec LOWEST|#)
              (make-call-expr :meth $1 :args $2))
             ((operation command-args cmd-brace-block)
              (make-call-expr :meth $1 :args $2 :block $3))
             ((primary-value :tDOT operation2 command-args #|%prec LOWEST|#)
              (make-call-expr :recv $1 :meth $3 :args $4))
             ((primary-value :tDOT operation2 command-args cmd-brace-block)
              (make-call-expr :recv $1 :meth $3 :args $4 :block  $5))
             ((primary-value :tCOLON2 operation2 command-args #|%prec LOWEST|#)
              (make-call-expr :recv $1 :meth $3 :args $4))
             ((primary-value :tCOLON2 operation2 command-args cmd-brace-block)
              (make-call-expr :recv $1 :meth $3 :args $4 :block $5))
             ((:kSUPER command-args)
              (make-super-expr :args $2 :loc $1))
             ((:kYIELD command-args)
              (make-yield-expr :args $2 :loc $1)))

    (mlhs ((mlhs-basic) $1)
          ((:tLPAREN mlhs-entry :tRPAREN) $2))

    (mlhs-entry ((mlhs-basic) $1)
                ((:tLPAREN mlhs-entry :tRPAREN)
                 (list (make-lhs-dest :list $2))))

    (mlhs-basic ((mlhs-head) $1)
                ((mlhs-head mlhs-item)
                 (append $1 (list $2)))
                ((mlhs-head :tSTAR mlhs-node)
                 (append $1 (list (make-lhs-rest :lhs $3))))
                ((mlhs-head :tSTAR)
                 (append $1 (list (make-lhs-star))))
                ((:tSTAR mlhs-node)
                 (list (make-lhs-rest :lhs $2)))
                ((:tSTAR)
                 (list (make-lhs-star))))

    (mlhs-item ((mlhs-node) $1)
               ((:tLPAREN mlhs-entry :tRPAREN)
                (make-lhs-dest :list $2)))

    (mlhs-head ((mlhs-item :tCOMMA) (list $1))
               ((mlhs-head mlhs-item :tCOMMA)
                (append $1 (list $2))))

    (mlhs-node ((variable)
                (new-assignable $1))
               ((primary-value |[| aref-args :tRBRACK)
                (make-lhs-aref :self $1 :args $3))
               ((primary-value :tDOT :tIDENTIFIER)
                (make-lhs-attr :self $1 :meth $3))
               ((primary-value :tCOLON2 :tIDENTIFIER)
                (make-lhs-attr :self $1 :meth $3))
               ((primary-value :tDOT :tCONSTANT)
                (make-lhs-attr :self $1 :meth $3))
               ((primary-value :tCOLON2 :tCONSTANT)
                (if (or (plusp (slot-value *state* 'in-def))
                        (plusp (slot-value *state* 'in-single)))
                    (yyerror "dynamic constant assignment")
                    (make-lhs-id :id (make-const :cpath (make-cpath-rel :base $1 :string $3)))))
               ((:tCOLON3 :tCONSTANT)
                (if (or (plusp (slot-value *state* 'in-def))
                        (plusp (slot-value *state* 'in-single)))
                    (yyerror "dynamic constant assignment")
                    (make-lhs-id :id (make-const :cpath (make-cpath-glob :cpath (make-cpath-name :string $2))))))
               ((backref)
                (backref-assign-error $1)))

    (lhs ((variable)
          (new-assignable $1))
         ((primary-value |[| aref-args :tRBRACK)
          (make-lhs-aref :self $1 :args $3))
         ((primary-value :tDOT :tIDENTIFIER)
          (make-lhs-attr :self $1 :meth $3))
         ((primary-value :tCOLON2 :tIDENTIFIER)
          (make-lhs-attr :self $1 :meth $3))
         ((primary-value :tDOT :tCONSTANT)
          (make-lhs-attr :self $1 :meth $3))
         ((primary-value :tCOLON2 :tCONSTANT)
          (if (or (plusp (slot-value *state* 'in-def))
                  (plusp (slot-value *state* 'in-single)))
              (yyerror "dynamic constant assignment")
              (make-lhs-id :id (make-const :cpath (make-cpath-rel :base $1 :string $3)))))
         ((:tCOLON3 :tCONSTANT)
          (if (or (plusp (slot-value *state* 'in-def))
                  (plusp (slot-value *state* 'in-single)))
              (yyerror "dynamic constant assignment")
              (make-lhs-id :id (make-const :cpath (make-cpath-glob :cpath (make-cpath-name :string $2)))))))

    (cname ((:tIDENTIFIER) (yyerror "class/module name must be :tCONSTANT"))
           ((:tCONSTANT) $1))

    (cpath ((:tCOLON3 cname)
            (make-cpath-glob :cpath (make-cpath-name :string $2))) }
            ((cname)
             (make-cpath-name :string $1))
            ((primary-value :tCOLON2 cname)
             (make-cpath-rel :base $1 :string $3)))

    (fname ((:tIDENTIFIER) $1)
           ((:tCONSTANT) $1)
           ((:tFID) $1)
           ((op)
            (setf (slot-value *state* 'lex-state) :expr-end)
            $1)
           ((reswords)
            (setf (slot-value *state* 'lex-state) :expr-end)
            $1))

    (fitem ((fname) $1)
           ((symbol) $1))

    (undef-list ((fitem) (list $1))
                ((undef-list :tCOMMA undef-list-e1 fitem)
                 (append $1 (list $4))))

    (undef-list-e1 (() (setf (slot-value *state* 'lex-state) :expr-fname)))

    (op ((:tPIPE)      "|")
        ((:tCARET)     "^")
        ((:tAMPER2)    "&")
        ((:tCMP)       "<=>")
        ((:tEQ)        "==")
        ((:tEQQ)       "===")
        ((:tMATCH)     "=~")
        ((:tGT)        ">")
        ((:tGEQ)       ">=")
        ((:tLT)        "<")
        ((:tLEQ)       "<=")
        ((:tLSHFT)     "<<")
        ((:tRSHFT)     ">>")
        ((:tPLUS)      "+")
        ((:tMINUS)     "-")
        ((:tSTAR2)     "*")
        ((:tSTAR)      "*")
        ((:tDIVIDE)    "/")
        ((:tPERCENT)   "%")
        ((:tPOW)       "**")
        ((:tTILDE)     "~")
        ((:tUPLUS)     "+@")
        ((:tUMINUS)    "-@")
        ((:tAREF)      "[]")
        ((:tASET)      "[]=")
        ((:tBACK-REF2) "`"))

    (reswords ((:k__LINE__)        "-__LINE__")
              ((:k__FILE__)        "-__FILE__")
              ((:klBEGIN)          "BEGIN")
              ((:klEND)            "END")
              ((:kALIAS)           "alias")
              ((:kAND)             "and")
              ((:kBEGIN)           "begin")
              ((:kBREAK)           "break")
              ((:kCASE)            "case")
              ((:kCLASS)           "class")
              ((:kDEF)             "def")
              ((:kDEFINED)         "defined")
              ((:kDO)              "do")
              ((:kELSE)            "else")
              ((:kELSIF)           "elsif")
              ((:kEND)             "end")
              ((:kENSURE)          "ensure")
              ((:kFALSE)           "false")
              ((:kFOR)             "for")
              ((:kIN)              "in")
              ((:kMODULE)          "module")
              ((:kNEXT)            "next")
              ((:kNIL)             "nil")
              ((:kNOT)             "not")
              ((:kOR)              "or")
              ((:kREDO)            "redo")
              ((:kRESCUE)          "rescue")
              ((:kRETRY)           "retry")
              ((:kRETURN)          "return")
              ((:kSELF)            "self")
              ((:kSUPER)           "super")
              ((:kTHEN)            "then")
              ((:kTRUE)            "true")
              ((:kUNDEF)           "undef")
              ((:kWHEN)            "when")
              ((:kYIELD)           "yield")
              ((:kIF-MOD)          "if")
              ((:kUNLESS-MOD)      "unless")
              ((:kWHILE-MOD)       "while")
              ((:kUNTIL-MOD)       "until")
              ((:kRESCUE-MOD)      "rescue"))

    (arg ((lhs :tEQL arg)
          (make-assign-expr :lhs $1 :rhs $3 :kind :single))
         ((lhs :tEQL arg :kRESCUE-MOD arg)
          (make-assign-expr :lhs $1
                            :rhs (make-begin-expr
                                  :body (make-body-stmt
                                         :body (list (make-expr-stmt :expr $3))
                                         :rescues (list (cons nil (list (make-expr-stmt :expr $5))))))
                            :kind :single))
         ((var-lhs :tOP-ASGN arg)
          (new-op-asgn $1 $2 $3))
         ((primary-value |[| aref-args :tRBRACK :tOP-ASGN arg)
          (new-op-asgn (make-lhs-aref :self $1 :args $3) $5 $6))
         ((primary-value :tDOT :tIDENTIFIER :tOP-ASGN arg)
          (new-op-asgn (make-lhs-attr :self $1 :meth $3) $4 $5))
         ((primary-value :tDOT :tCONSTANT :tOP-ASGN arg)
          (new-op-asgn (make-lhs-attr :self $1 :meth $3) $4 $5))
         ((primary-value :tCOLON2 :tIDENTIFIER :tOP-ASGN arg)
          (new-op-asgn (make-lhs-attr :self $1 :meth $3) $4 $5))
         ((primary-value :tCOLON2 :tCONSTANT :tOP-ASGN arg)
          (yyerror "constant re-assignment"))
         ((:tCOLON3 :tCONSTANT :tOP-ASGN arg)
          (yyerror "constant re-assignment"))
         ((backref :tOP-ASGN arg)
          (backref-assign-error $1))
         ((arg :tDOT2 arg)
          #| TODO
          v1, v2 = val[0], val[2]
          if v1.node-type == :lit and v2.node-type == :lit and Fixnum === v1.last and Fixnum === v2.last then
          result = s(:lit, (v1.last)..(v2.last))
          else
          result = s(:dot2, v1, v2)
          end
          |#
          (make-dot2-expr :lhs $1 :rhs $3 :loc $2))
         ((arg :tDOT3 arg)
          #| TODO
          v1, v2 = val[0], val[2]
          if v1.node-type == :lit and v2.node-type == :lit and Fixnum === v1.last and Fixnum === v2.last then
          result = s(:lit, (v1.last)...(v2.last))
          else
          result = s(:dot3, v1, v2)
          end
          |#
          (make-dot3-expr :lhs $1 :rhs $3 :loc $2))
         ((arg :tPLUS arg)
          (make-call-expr :recv $1 :meth "+" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tMINUS arg)
          (make-call-expr :recv $1 :meth "-" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tSTAR2 arg)
          (make-call-expr :recv $1 :meth "*" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tDIVIDE arg)
          (make-call-expr :recv $1 :meth "/" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tPERCENT arg)
          (make-call-expr :recv $1 :meth "%" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tPOW arg)
          (make-call-expr :recv $1 :meth "**" :args (list (make-arg-value :expr $3)) :loc $2))
         ((:tUMINUS-NUM :tINTEGER :tPOW arg)
          (make-call-expr :recv (make-call-expr :recv (make-lit-expr :lit (make-integer-lit :value $2))
                                                :meth "**"
                                                :args (list (make-arg-value :expr $4))
                                                :loc $3)
                          :meth "-@"
                          :loc $1))
         ((:tUMINUS-NUM :tFLOAT :tPOW arg)
          (make-call-expr :recv (make-call-expr :recv (make-lit-expr :lit (make-float-lit :value $2))
                                                :meth "**"
                                                :args (list (make-arg-value :expr $4))
                                                :loc $3)
                          :meth "-@"
                          :loc $1))
         ((:tUPLUS arg)
          (match $2
            ((literal) $2)
            (otherwise
             (make-call-expr :recv $2 :meth "+@" :loc $1))))
         ((:tUMINUS arg)
          (make-call-expr :recv $2 :meth "-@" :loc $1))
         ((arg :tPIPE arg)
          (make-call-expr :recv $1 :meth "|" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tCARET arg)
          (make-call-expr :recv $1 :meth "^" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tAMPER2 arg)
          (make-call-expr :recv $1 :meth "&" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tCMP arg)
          (make-call-expr :recv $1 :meth "<=>" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tGT arg)
          (make-call-expr :recv $1 :meth ">" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tGEQ arg)
          (make-call-expr :recv $1 :meth ">=" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tLT arg)
          (make-call-expr :recv $1 :meth "<" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tLEQ arg)
          (make-call-expr :recv $1 :meth "<=" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tEQ arg)
          (make-call-expr :recv $1 :meth "==" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tEQQ arg)
          (make-call-expr :recv $1 :meth "===" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tNEQ arg)
          (make-not-expr :expr (make-call-expr :recv $1
                                               :meth "=="
                                               :args (list (make-arg-value :expr $3)))))
         ((arg :tMATCH arg)
          (get-match-node $1 $3 :loc $2))
         ((arg :tNMATCH arg)
          (make-not-expr :expr (get-match-node $1 $3 :loc $2)))
         ((:tBANG arg)
          (make-not-expr :expr $2 :loc $1))
         ((:tTILDE arg)
          (make-call-expr :recv $2 :meth "~" :loc $1))
         ((arg :tLSHFT arg)
          (make-call-expr :recv $1 :meth "<<" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tRSHFT arg)
          (make-call-expr :recv $1 :meth ">>" :args (list (make-arg-value :expr $3)) :loc $2))
         ((arg :tANDOP arg)
          (new-logop $1 :and $3))
         ((arg :tOROP arg)
          (new-logop $1 :or $3))
         ((:kDEFINED opt-nl arg)
          (make-defined-expr :expr $3))
         ((arg :tEH arg :tCOLON arg)
          (make-tern-expr :test $1 :then $3 :else $5 :loc (node-loc $1)))
         ((primary)
          $1))

    (arg-value ((arg) $1))

    (aref-args (() ())
               ((command opt-nl)
                (rb-warning "parenthesize argument(s) for future version")
                (list (make-arg-value :expr $1)))
               ((args trailer) $1)
               ((args :tCOMMA :tSTAR arg opt-nl)
                (append $1 (list (make-arg-value :expr $4))))
               ((assocs trailer)
                (list (make-arg-hash :list $1)))
               ((:tSTAR arg opt-nl)
                (list (make-arg-splat :expr $2))))

    (paren-args ((:tLPAREN2 none :tRPAREN) ())
                ((:tLPAREN2 call-args opt-nl :tRPAREN) $2)
                ((:tLPAREN2 block-call opt-nl :tRPAREN)
                 (rb-warning "parenthesize argument(s) for future version")
                 (list (make-arg-value :expr $2)))
                ((:tLPAREN2 args :tCOMMA block-call opt-nl :tRPAREN)
                 (rb-warning "parenthesize argument(s) for future version")
                 (append $2 (list (make-arg-value :expr $4)))))

    (opt-paren-args (() ())
                    ((paren-args) $1))

    (call-args ((command)
                (rb-warning "parenthesize argument(s) for future version")
                ())
               ((args opt-block-arg)
                (append $1 $2))
               ((args :tCOMMA :tSTAR arg-value opt-block-arg)
                (append $1 (cons (make-arg-splat :expr $4) $5)))
               ((assocs opt-block-arg)
                (make-arg-hash :list (cons $1 $2)))
               ((assocs :tCOMMA :tSTAR arg-value opt-block-arg)
                (make-arg-hash :list (list* $1 (make-arg-splat :expr $4) $5)))
               ((args :tCOMMA assocs opt-block-arg)
                (append $1 (make-arg-hash :list (cons $3 $4))))
               ((args :tCOMMA assocs :tCOMMA :tSTAR arg opt-block-arg)
                (append $1 (make-arg-hash :list (list* $3 (make-arg-splat :expr $6) $7))))
               ((:tSTAR arg-value opt-block-arg)
                (cons (make-arg-splat :expr $2) $3))
               ((block-arg) (list $1)))
    
    (call-args2 ((arg-value :tCOMMA args opt-block-arg)
                 (append (cons (make-arg-value :expr $1) $3) $4))
                ((arg-value :tCOMMA block-arg)
                 (list (make-arg-value :expr $1) $3))
                ((arg-value :tCOMMA :tSTAR arg-value opt-block-arg)
                 (list* (make-arg-value :expr $1) (make-arg-splat :expr $4) $5))
                ((arg-value :tCOMMA args :tCOMMA :tSTAR arg-value opt-block-arg)
                 (append (cons (make-arg-value :expr $1) $3)
                         (cons (make-arg-splat :expr $6) $7)))
                ((assocs opt-block-arg)
                 (cons (make-arg-hash :list $1) $2))
                ((assocs :tCOMMA :tSTAR arg-value opt-block-arg)
                 (list* (make-arg-hash :list $1) (make-arg-splat :expr $4) $5))
                ((arg-value :tCOMMA assocs opt-block-arg)
                 (list* (make-arg-value :expr $1) (make-arg-hash :list $3) $4))
                ((arg-value :tCOMMA args :tCOMMA assocs opt-block-arg)
                 (append (cons (make-arg-value :expr $1) $3)
                         (cons (make-arg-hash :list $5) $6)))
                ((arg-value :tCOMMA assocs :tCOMMA :tSTAR arg-value opt-block-arg)
                 (list* (make-arg-value :expr $1)
                        (make-arg-hash :list $3)
                        (make-arg-splat :expr $6)
                        $7))
                ((arg-value :tCOMMA args :tCOMMA assocs :tCOMMA :tSTAR arg-value opt-block-arg)
                 (append (cons (make-arg-value :expr $1) $3)
                         (list* (make-arg-hash :list $5)
                                (make-arg-splat :expr $8)
                                $9)))
                ((:tSTAR arg-value opt-block-arg)
                 (cons (make-arg-splat :expr $2) $3))
                ((block-arg) (list $1)))

    (command-args ((command-args-e1 open-args)
                   (setf (slot-value *state* 'cmdarg) (make-stack-state :list $1))
                   $2))
    
    (command-args-e1 (()
                      (let ((list (stack-state-list (slot-value *state* 'cmdarg))))
                        (stack-state-push (slot-value *state* 'cmdarg) t)
                        list)))

    (open-args ((call-args) $1)
               ((:tLPAREN-ARG open-args-e1 :tRPAREN)
                (rb-warning "don't put space before argument parentheses")
                ())
               ((:tLPAREN-ARG call-args2 open-args-e1 :tRPAREN)
                (rb-warning "don't put space before argument parentheses")
                $2))

    (open-args-e1 (() (setf (slot-value *state* 'lex-state) :expr-endarg)))

    (block-arg ((:tAMPER arg-value) (make-arg-block :expr $2)))

    (opt-block-arg ((:tCOMMA block-arg) (list $2))
                   (() ()))

    (args ((arg-value)
           (list (make-arg-value :expr $1)))
          ((args :tCOMMA arg-value)
           (append $1 (list (make-arg-value :expr $3)))))

    (mrhs ((args :tCOMMA arg-value)
           (append $1 (list (make-arg-value :expr $3))))
          ((args :tCOMMA :tSTAR arg-value)
           (append $1 (list (make-arg-splat :expr $4))))
          ((:tSTAR arg-value)
           (list (make-arg-splat :expr $2))))
    
    (primary ((literal) $1)
             ((strings) $1)
             ((xstring) $1)
             ((regexp) $1)
             ((words) $1)
             ((awords) $1)
             ((var-ref) $1)
             ((backref) $1)
             ((:tFID)
              (make-call-expr :meth $1))
             ((:kBEGIN bodystmt :kEND)
              (make-begin-expr :body $2 :loc $1))
             ((:tLPAREN-ARG expr primary-e1 opt-nl :tRPAREN)
              (rb-warning "(...) interpreted as grouped expression")
              $2)
             ((:tLPAREN compstmt :tRPAREN)
              (match $2
                (() (make-id-expr :id (make-pvar :name :nil) :loc $1))
                (_  (make-block-expr :body $2 :loc $1))))
             ((primary-value :tCOLON2 :tCONSTANT)
              (make-id-expr :id (make-const :cpath (make-cpath-rel :base $1 :string $3))))
             ((:tCOLON3 :tCONSTANT)
              (make-id-expr :id (make-const :cpath (make-cpath-glob :cpath (make-cpath-name :string $2)))))
             ((primary-value |[| aref-args :tRBRACK)
              (new-aref $1 $3 :loc $2))
             ((:tLBRACK aref-args :tRBRACK)
              (make-array-expr :args $2 :loc $1))
             ((:tLBRACE assoc-list :tRCURLY)
              (make-hash-expr :args $2 :loc $1))
             ((:kRETURN)
              (make-return-expr :loc $1))
             ((:kYIELD :tLPAREN2 call-args :tRPAREN)
              (make-yield-expr :args $3 :loc $1))
             ((:kYIELD :tLPAREN2 :tRPAREN)
              (make-yield-expr :loc $1))
             ((:kYIELD)
              (make-yield-expr :loc $1))
             ((:kDEFINED opt-nl :tLPAREN2 expr :tRPAREN)
              (make-defined-expr :expr $4 :loc $1))
             ((operation brace-block)
              (make-call-expr :meth $1 :block $2))
             ((method-call)
              $1)
             ((method-call brace-block)
              (match $1
                ((call-expr recv meth args loc)
                 (make-call-expr :recv recv :meth meth :args args :block $2 :loc loc))
                (_ (error "invalid method-call"))))
             ((:kIF expr-value then compstmt if-tail :kEND)
              (make-if-expr :test $2 :then $4 :else $5 :loc $1))
             ((:kUNLESS expr-value then compstmt opt-else :kEND)
              (make-unless-expr :test $2 :then $4 :else $5 :loc $1))
             ((:kWHILE
               primary-e2
               expr-value do
               primary-e3
               compstmt :kEND)
              (make-while-expr :test $3 :body $6 :loc $1))
             ((:kUNTIL
               primary-e2
               expr-value do
               primary-e3
               compstmt :kEND)
              (make-until-expr :test $3 :body $6 :loc $1))
             ((:kCASE expr-value opt-terms case-body opt-else :kEND)
              (make-case-expr :test $2 :whens $4 :else $5 :loc $1))
             ((:kCASE opt-terms case-body opt-else :kEND)
              (make-case-expr :whens $3 :else $4 :loc $1))
             ((:kCASE opt-terms :kELSE compstmt :kEND)
              (make-case-expr :else $4 :loc $1))
             ((:kFOR
               block-var :kIN
               primary-e2
               expr-value do
               primary-e3
               compstmt :kEND)
              (make-for-expr :lhs $2 :gen $5 :body $8 :loc $1))
             ((:kCLASS
               cpath superclass
               primary-e4
               bodystmt :kEND)
              (prog1 (make-class-expr :cpath $2 :super $3 :body $5 :loc $1)
                (env-unextend (slot-value *state* 'env))))
             ((:kCLASS
               :tLSHFT
               expr
               primary-e5
               term
               primary-e6
               bodystmt :kEND)
              (prog1 (make-sclass-expr :expr $3 :body $7 :loc $1)
                (setf (slot-value *state* 'in-def) $4)
                (setf (slot-value *state* 'in-single) $6)
                (env-unextend (slot-value *state* 'env))))
             ((:kMODULE
               cpath
               primary-e7
               bodystmt :kEND)
              (prog1 (make-module-expr :cpath $2 :body $4)
                (env-unextend (slot-value *state* 'env))))
             ((:kDEF
               fname
               primary-e8
               f-arglist bodystmt :kEND)
              (prog1 (make-defn-expr :name $2 :params $4 :body $5)
                (env-unextend (slot-value *state* 'env))
                (decf (slot-value *state* 'in-def))))
             ((:kDEF
               singleton dot-or-colon
               primary-e9
               fname
               primary-e10
               f-arglist bodystmt :kEND)
              (prog1 (make-defs-expr :expr $2 :name $5 :params $7 :body $8 :loc $1)
                (env-unextend (slot-value *state* 'env))
                (decf (slot-value *state* 'in-single))))
             ((:kBREAK)
              (make-break-expr :loc $1))
             ((:kNEXT)
              (make-next-expr :loc $1))
             ((:kREDO)
              (make-redo-expr :loc $1))
             ((:kRETRY)
              (make-retry-expr :loc $1)))

    (primary-e1 (() (setf (slot-value *state* 'lex-state) :expr-endarg)))
    (primary-e2 (() (stack-state-push (slot-value *state* 'cond) t)))
    (primary-e3 (() (stack-state-pop (slot-value *state* 'cond))))
    (primary-e4 (()
                 (if (or (plusp (slot-value *state* 'in-def))
                         (plusp (slot-value *state* 'in-single)))
                     (yyerror "class definition in method body")
                     (env-extend (slot-value *state* 'env)))))
    (primary-e5 (()
                 (let ((in-def (slot-value *state* 'in-def)))
                   (setf (slot-value *state* 'in-def) 0)
                   in-def)))
    (primary-e6 (()
                 (let ((in-single (slot-value *state* 'in-single)))
                   (setf (slot-value *state* 'in-single) 0)
                   (env-extend (slot-value *state* 'env))
                   in-single)))
    (primary-e7 (()
                 (if (or (plusp (slot-value *state* 'in-def))
                         (plusp (slot-value *state* 'in-single)))
                     (yyerror "module definition in method body")
                     (env-extend (slot-value *state* 'env)))))
    (primary-e8 (()
                 (incf (slot-value *state* 'in-def))
                 (env-extend (slot-value *state* 'env))))
    (primary-e9 (()
                 (setf (slot-value *state* 'lex-state) :expr-fname)))
    (primary-e10 (()
                  (incf (slot-value *state* 'in-single))
                  (env-extend (slot-value *state* 'env))
                  (setf (slot-value *state* 'lex-state) :expr-end)))

    (primary-value ((primary) $1))

    (then ((term) ())
          ((:tCOLON) ())
          ((:kTHEN) ())
          ((term :kTHEN) ()))

    (do ((term) ())
        ((:tCOLON) ())
        ((:kDO-COND) ()))

    (if-tail ((opt-else) $1)
             ((:kELSIF expr-value then compstmt if-tail)
              (list (make-expr-stmt :expr (make-if-expr :test $2 :then $4 :else $5 :loc $1)))))

    (opt-else (() ())
              ((:kELSE compstmt) $2))

    (block-var ((lhs) $1)
               ((mlhs) (make-lhs-dest :list $1)))

    (opt-block-var (() ())
                   ((:tPIPE :tPIPE) ())
                   ((:tOROP) ())
                   ((:tPIPE lhs :tPIPE) (list $2))
                   ((:tPIPE mlhs :tPIPE) $2))

    (do-block ((:kDO-BLOCK
                do-block-e1
                opt-block-var
                compstmt :kEND)
               (prog1 (make-blk :vars $3 :body $3)
                 (env-unextend (slot-value *state* 'env)))))
    (do-block-e1 (() (env-extend (slot-value *state* 'env) t)))

    (block-call ((command do-block)
                 (match $1
                   ((call-expr recv meth args loc)
                    (make-call-expr :recv recv :meth meth :args args :block $2 :loc loc))
                   ((super-expr args loc)
                    (make-super-expr :args args :block $2 :loc loc))
                   ((yield-expr)
                    $1)
                   (otherwise
                    (error "invalid block-call"))))
                ((block-call :tDOT operation2 opt-paren-args)
                 (make-call-expr :recv $1 :meth $3 :args $4))
                ((block-call :tCOLON2 operation2 opt-paren-args)
                 (make-call-expr :recv $1 :meth $3 :args $4)))

    (method-call ((operation paren-args)
                  (make-call-expr :meth $1 :args $2))
                 ((primary-value :tDOT operation2 opt-paren-args)
                  (make-call-expr :recv $1 :meth $3 :args $4))
                 ((primary-value :tCOLON2 operation2 paren-args)
                  (make-call-expr :recv $1 :meth $3 :args $4))
                 ((primary-value :tCOLON2 operation3)
                  (make-call-expr :recv $1 :meth $3))
                 ((:kSUPER paren-args)
                  (make-super-expr :args $2 :loc $1))
                 ((:kSUPER)
                  (make-zsuper-expr :loc $1)))

    (brace-block ((:tLCURLY
                   brace-block-e1
                   opt-block-var
                   compstmt :tRCURLY)
                  (prog1 (make-blk :vars $3 :body $4)
                    (env-unextend (slot-value *state* 'env))))
                 ((:kDO
                   brace-block-e1
                   opt-block-var
                   compstmt :kEND)
                  (prog1 (make-blk :vars $3 :body $4)
                    (env-unextend (slot-value *state* 'env)))))
    (brace-block-e1 (() (env-extend (slot-value *state* 'env) t)))

    (case-body ((:kWHEN
                 when-args then compstmt cases)
                (cons (cons $2 $4) $5)))

    (when-args ((args) $1)
               ((args :tCOMMA :tSTAR arg-value)
                (append $1 (list (make-arg-splat :expr $4))))
               ((:tSTAR arg-value)
                (list (make-arg-splat :expr $2))))

    (cases ((case-body) $1)
           (() ()))

    (opt-rescue ((:kRESCUE exc-list exc-var then compstmt opt-rescue)
                 (let ((body
                         (if $3
                             (let ((asgn
                                     (make-assign-expr :lhs $3
                                                       :rhs (make-id-expr :id (make-gvar :name "!"))
                                                       :kind :single)))
                               (cons (make-expr-stmt :expr asgn) $5))
                             $5)))
                   (cons (cons $2 body) $6)))
                (() ()))

    (exc-list ((arg-value) (list (make-arg-value :expr $1)))
              ((mrhs) $1)
              (() ()))

    (exc-var ((:tASSOC lhs) $2)
             (() nil))

    (opt-ensure ((:kENSURE compstmt) $2)
                (() ()))

    (literal ((numeric)
              (make-lit-expr :lit (etypecase $1
                                    (integer (make-integer-lit :value $1))
                                    (float (make-float-lit :value $1)))))
             ((symbol)
              (make-lit-expr :lit (make-string-lit :value (list $1))))
             ((dsym) $1))

    (strings ((string) $1))

    (string ((string1) $1)
            ((string string1)
             (literal-concat $1 $2)))

    (string1 ((:tSTRING-BEG string-contents :tSTRING-END)
              (make-lit-expr :lit (make-string-lit :value $2)))
             ((:tSTRING)
              (make-lit-expr :lit (make-string-lit :value (list $1)))))

    (xstring ((:tXSTRING-BEG xstring-contents :tSTRING-END)
              (make-lit-expr :lit (make-xstring-lit :value $2))))

    (regexp ((:tREGEXP-BEG xstring-contents :tREGEXP-END)
             (make-lit-expr :lit (make-regexp-lit :value $2))))

    (words ((:tWORDS-BEG :tSPACE :tSTRING-END)
            (make-array-expr :loc $1))
           ((:tWORDS-BEG word-list :tSTRING-END)
            (make-array-expr :args $2 :loc $1)))

    (word-list (() ())
               ((word-list word :tSPACE)
                (append $1 (list (make-arg-value :expr $2)))))

    (word ((string-content)
           (make-lit-expr :lit (make-string-lit :value (list $1))))
          ((word string-content)
           (literal-concat $1 (make-lit-expr :lit (make-string-lit :value (list $2))))))

    (awords ((:tAWORDS-BEG :tSPACE :tSTRING-END)
             (make-array-expr :loc $1))
            ((:tAWORDS-BEG qword-list :tSTRING-END)
             (make-array-expr :args $2 :loc $1)))

    (qword-list (() ())
              ((qword-list :tSTRING-CONTENT :tSPACE)
               (append $1 (list (make-arg-value :expr (make-lit-expr :lit (make-string-lit :value (list $2))))))))

    (string-contents (() ())
                     ((string-contents string-content)
                      (append $1 (list $2))))

    (xstring-contents (() ())
                      ((xstring-contents string-content)
                       (append $1 (list $2))))

    (string-content ((:tSTRING-CONTENT) $1)
                    ((:tSTRING-DVAR
                      string-content-e1
                      string-dvar)
                     (setf (slot-value *state* 'lex-strterm) $2)
                     (cons $3 $1))
                    ((:tSTRING-DBEG
                      string-content-e2
                      compstmt :tRCURLY)
                     (setf (slot-value *state* 'lex-strterm) $2)
                     (stack-state-lexpop (slot-value *state* 'cond))
                     (stack-state-lexpop (slot-value *state* 'cmdarg))
                     (cons (make-block-expr :body $3) $1)))

    (string-content-e1 (()
                        (prog1 (slot-value *state* 'lex-strterm)
                          (setf (slot-value *state* 'lex-strterm) nil)
                          (setf (slot-value *state* 'lex-state) :expr-beg))))
    (string-content-e2 (()
                        (prog1 (slot-value *state* 'lex-strterm)
                          (setf (slot-value *state* 'lex-strterm) nil)
                          (setf (slot-value *state* 'lex-state) :expr-beg)
                          (stack-state-push (slot-value *state* 'cond) nil)
                          (stack-state-push (slot-value *state* 'cmdarg) nil))))

    (string-dvar ((:tGVAR)  (make-id-expr :id (make-gvar :name $1)))
                 ((:tIVAR)  (make-id-expr :id (make-ivar :name $1)))
                 ((:tCVAR)  (make-id-expr :id (make-cvar :name $1)))
                 ((backref) $1))
    
    (symbol ((:tSYMBEG sym)
             (setf (slot-value *state* 'lex-state) :expr-end)
             $2)
            ((:tSYMBOL)
             $1))

    (sym ((fname)  $1)
         ((:tIVAR) $1)
         ((:tGVAR) $1)
         ((:tCVAR) $1))

    (dsym ((:tSYMBEG xstring-contents :tSTRING-END)
           (make-lit-expr :lit (make-symbol-lit :value $2) :loc $1)))

    (numeric ((:tINTEGER) $1)
             ((:tFLOAT)   $1)
             ((:tUMINUS-NUM :tINTEGER #|%prec LOWEST|#)
              (- $2))
             ((:tUMINUS-NUM :tFLOAT #|%prec LOWEST|#)
              (- $2)))

    (variable ((:tIDENTIFIER) $1)
              ((:tIVAR)       $1)
              ((:tGVAR)       $1)
              ((:tCONSTANT)   $1)
              ((:tCVAR)       $1)
              ((:kNIL)       "nil")
              ((:kSELF)      "self")
              ((:kTRUE)      "true")
              ((:kFALSE)     "false")
              ((:k__FILE__)  "-__FILE__")
              ((:k__LINE__)  "-__LINE__"))

    (var-ref ((variable)
              (gettable $1)))

    (var-lhs ((variable)
              (new-assignable $1)))

    (backref ((:tNTH-REF) (make-nth-ref-expr :n $1))
             ((:tBACK-REF) (make-back-ref-expr :c $1)))

    (superclass ((term) nil)
                ((:tLT
                  superclass-e1
                  expr-value term)
                 $3)
                ((error term) nil))
    (superclass-e1 (()
                    (setf (slot-value *state* 'lex-state) :expr-beg)))

    (f-arglist ((:tLPAREN2 f-args opt-nl :tRPAREN)
                (setf (slot-value *state* 'lex-state) :expr-beg)
                $2)
               ((f-args term) $1))

    (f-args ((f-arg :tCOMMA f-optarg :tCOMMA f-rest-arg opt-f-block-arg)
             (append $1 $3 $5 $6))
            ((f-arg :tCOMMA f-optarg opt-f-block-arg)
             (append $1 $3 () $4))
            ((f-arg :tCOMMA f-rest-arg opt-f-block-arg)
             (append $1 () $3 $4))
            ((f-arg opt-f-block-arg)
             (append $1 () () $2))
            ((f-optarg :tCOMMA f-rest-arg opt-f-block-arg)
             (append () $1 $3 $4))
            ((f-optarg opt-f-block-arg)
             (append () $1 () $2))
            ((f-rest-arg opt-f-block-arg)
             (append () () $1 $2))
            ((f-block-arg)
             (append () () () $1))
            (() ()))

    (f-norm-arg ((:tCONSTANT)
                 (yyerror "formal argument cannot be a constant: ~A" $1))
                ((:tIVAR)
                 (yyerror "formal argument cannot be an instance variable"))
                ((:tCVAR)
                 (yyerror "formal argument cannot be a class variable"))
                ((:tIDENTIFIER)
                 (env-add (slot-value *state* 'env) $1 :lvar)
                 (make-param :name $1)))

    (f-arg ((f-norm-arg)
            (list $1))
           ((f-arg :tCOMMA f-norm-arg)
            (append $1 (list $3))))

    (f-opt ((:tIDENTIFIER :tEQL arg-value)
            (new-assignable $1)
            (make-opt-param :name $1 :init $3)))

    (f-optarg ((f-opt)
               (list $1))
              ((f-optarg :tCOMMA f-opt)
               (append $1 (list $3))))

    (restarg-mark ((:tSTAR2) $1)
                  ((:tSTAR)  $1))

    (f-rest-arg ((restarg-mark :tIDENTIFIER)
                 (new-assignable $2)
                 (list (make-rest-param :name $2)))
                ((restarg-mark)
                 (env-add (slot-value *state* 'env) "*" :lvar)
                 (list (make-star-param))))

    (blkarg-mark ((:tAMPER2) $1)
                 ((:tAMPER)  $1))

    (f-block-arg ((blkarg-mark :tIDENTIFIER)
                  (let ((id $2))
                    (env-add (slot-value *state* 'env) id :lvar)
                    (list (make-block-param :name id)))))

    (opt-f-block-arg ((:tCOMMA f-block-arg) $2)
                     (() ()))

    (singleton ((var-ref) $1)
               ((:tLPAREN2
                 singleton-e1
                 expr opt-nl :tRPAREN)
                $3))
    (singleton-e1 (() (setf (slot-value *state* 'lex-state) :expr-beg)))

    (assoc-list (() ())
                ((assocs trailer) $1)
                ((args trailer)
                 (mapcar (lambda-match
                           ((arg-value expr) expr)
                           (otherwise (error "invalid assoc")))
                         $1)))

    (assocs ((assoc) $1)
            ((assocs :tCOMMA assoc)
             (append $1 $3)))

    (assoc ((arg-value :tASSOC arg-value)
            (list $1 $3)))

    (operation ((:tIDENTIFIER) $1)
               ((:tCONSTANT)   $1)
               ((:tFID)        $1))
    (operation2 ((:tIDENTIFIER) $1)
                ((:tCONSTANT)   $1)
                ((:tFID)        $1)
                ((op)         $1))
    (operation3 ((:tIDENTIFIER) $1)
                ((:tFID)        $1)
                ((op)         $1))
    (dot-or-colon ((:tDOT)    $1)
                  ((:tCOLON2) $1))
    (opt-terms (() ())
               ((terms) ()))
    (opt-nl (() ())
            ((:tNL) ()))
    (trailer (() ())
             ((:tNL) ())
             ((:tCOMMA) ()))

    (term ((:tSEMI) ())
          ((:tNL)   ()))

    (terms ((term) ())
           ((terms :tSEMI) ()))

    (none (() ()))

    (none-block-pass (() ()))))

(defun parse-from-stream (stream)
  (let ((*state* (make-lexer (make-source-from-stream stream))))
    (yacc:parse-with-lexer *state* *parser*)))

(defun parse-from-string (string)
  (with-input-from-string (stream string)
    (parse-from-stream stream)))

(defun parse-from-file (filename)
  (with-open-file (stream filename)
    (parse-from-stream stream)))
