(in-package :ruby-parser.ast)

(deftype proper-list (&optional element)
  (declare (ignore element))
  'list)

(defmacro defvariant (name-and-options &body clauses)
  (setq name-and-options (ensure-list name-and-options))
  (let ((variant-name (first name-and-options))
        (variant-constructor-lambda-list (third (assoc :constructor (cdr name-and-options)))))
    `(progn
       (defstruct ,name-and-options)
       ,@(iter (for (name-and-options . slot-specs) in clauses)
               (for (name . options) = (ensure-list name-and-options))
               (for (constructor-name constructor-lambda-list)
                    = (aif (assoc :constructor options)
                           (list (second it) (third it))
                           (list (symbolicate :make- name)
                                 (append (mapcar #'ensure-car slot-specs)
                                         variant-constructor-lambda-list))))
               (collect
                `(defstruct (,name ,@(remove :constructor options :key #'car)
                                   (:include ,variant-name)
                                   (:constructor ,constructor-name ,constructor-lambda-list))
                   ,@(iter (for slot-spec in slot-specs)
                           (for (slot-name slot-type) = (ensure-list slot-spec))
                           (collect`(,slot-name (required-argument) :type ,(or slot-type t))))))))))

(defstruct node loc)

(defmacro defnode (name &body clauses)
  `(defvariant (,name (:include node)
                      (:constructor ,(symbolicate :make- name) (&key loc)))
     ,@clauses))

;;; Literals

(defnode literal
  (string-lit (value (proper-list string-content)))
  (xstring-lit (value (proper-list string-content)))
  (symbol-lit (value (proper-list string-content)))
  (integer-lit (value integer))
  (float-lit (value float))
  ((regexp-lit (:constructor make-regexp-lit (value &key option loc)))
   (value (proper-list string-content))
   (option regexp-option)))

(deftype string-content ()
  '(or string expr))

(deftype regexp-option ()
  '(member nil :once))

;;; Variables

(defnode variable
  (lvar (name string))
  (dvar (name string))
  (ivar (name string))
  (cvar (name string))
  (gvar (name string))
  (const (path cpath))
  (pvar (name pseudo-variable)))

(defnode cpath
  (cpath-base (name string))
  (cpath-rel (expr expr)
             (name string))
  (cpath-abs (path cpath)))

(deftype pseudo-variable ()
  '(member :nil :true :false :self :__FILE__ :__LINE__))

;;; Parameters

(defnode parameter
  (req-param (name string))
  (opt-param (name string)
             (init expr))
  (rest-param (name string))
  (star-param)
  (block-param (name string)))

;;; Arguments

(defnode argument
  (value-arg (expr expr))
  (splat-arg (expr expr))
  (block-arg (expr expr))
  (hash-arg (list (proper-list expr))))

;;; LHS

(defnode lhs
  (lhs-var (var variable))
  (lhs-decl (var variable))
  (lhs-dest (list (proper-list lhs)))
  (lhs-rest (lhs lhs))
  (lhs-star)
  (lhs-attr (self expr)
            (name string))
  (lhs-aref (self expr)
            (args (proper-list argument)))
  (lhs-op (lhs lhs)
          (name string))
  (lhs-or (lhs lhs))
  (lhs-and (lhs lhs)))

;;; Misc

(defstruct (block (:include node)
                  (:constructor make-block (lhs body &key loc)))
  (lhs (required-argument) :type (proper-list lhs))
  (body (required-argument) :type (proper-list stmt)))

(deftype assign-kind ()
  '(member :single :svalue :multi))

;;; Statements

(defnode stmt
  (alias-stmt (new string)
              (old string))
  (undef-stmt (names (proper-list string)))
  (if-mod-stmt (body stmt)
               (test expr))
  (unless-mod-stmt (body stmt)
                   (test expr))
  (while-mod-stmt (body stmt)
                  (test expr))
  (until-mod-stmt (body stmt)
                  (test expr))
  (rescue-mod-stmt (body stmt)
                   (else stmt))
  (pre-exec-stmt (body (proper-list stmt)))
  (post-exec-stmt (body (proper-list stmt)))
  (expr-stmt (expr expr)))

;;; Expressions

(defnode expr
  (lit-expr (lit literal))
  (var-expr (var variable))
  (nth-ref-expr (index fixnum))
  (back-ref-expr (char character))
  (array-expr (args (proper-list argument)))
  (hash-expr (args (proper-list expr)))
  (dot2-expr (lhs expr)
             (rhs expr))
  (dot3-expr (lhs expr)
             (rhs expr))
  (not-expr (test expr))
  (and-expr (lhs expr)
            (rhs expr))
  (or-expr (lhs expr)
           (rhs expr))
  (defined-expr (test expr))
  (ternary-expr (test expr)
                (then expr)
                (else expr))
  (if-expr (test expr)
           (then (proper-list stmt))
           (else (proper-list stmt)))
  (unless-expr (test expr)
               (then (proper-list stmt))
               (else (proper-list stmt)))
  (while-expr (test expr)
              (body (proper-list stmt)))
  (until-expr (test expr)
              (body (proper-list stmt)))
  (for-expr (lhs lhs)
            (gen expr)
            (body (proper-list stmt)))
  ((case-expr (:constructor make-case-expr (&key (test nil) (whens nil) (else nil) loc)))
   (test (or null expr))
   (whens (proper-list (cons (proper-list argument)
                             (proper-list stmt))))
   (else (proper-list stmt)))
  ((break-expr (:constructor make-break-expr (&key (args nil) loc)))
   (args (proper-list argument)))
  ((next-expr (:constructor make-next-expr (&key (args nil) loc)))
   (args (proper-list argument)))
  (redo-expr)
  (retry-expr)
  ((call-expr (:constructor make-call-expr (&key (self nil) name (args nil) (block nil) loc)))
   (self (or null expr))
   (name string)
   (args (proper-list argument))
   (block (or null block)))
  ((return-expr (:constructor make-return-expr (&key (args nil) loc)))
   (args (proper-list argument)))
  ((yield-expr (:constructor make-yield-expr (&key (args nil) loc)))
   (args (proper-list argument)))
  ((super-expr (:constructor make-super-expr (&key (args nil) (block nil) loc)))
   (args (or (proper-list argument) (member t)))
   (block (or null block)))
  (assign-expr (lhs lhs)
               (rhs expr)
               (kind assign-kind))
  ((body-stmt (:constructor make-body-stmt (&key (body nil) (rescues nil) (else nil) (ensure nil))))
   (body (proper-list stmt))
   (rescues (proper-list (cons (proper-list argument)
                               (proper-list stmt))))
   (else (proper-list stmt))
   (ensure (proper-list stmt)))
  ((class-expr (:constructor make-class-expr (path body &key (super nil) loc)))
   (path cpath)
   (super (or null expr))
   (body body-stmt))
  (sclass-expr (expr expr)
               (body body-stmt))
  (module-expr (path cpath)
               (body body-stmt))
  (defn-expr (name string)
             (params (proper-list parameter))
             (body body-stmt))
  (defs-expr (expr expr)
             (name string)
             (params (proper-list parameter))
             (body body-stmt))
  (begin-expr (body body-stmt))
  (seq-expr (body (proper-list stmt))))

;;; Sexp

(defun literal-to-sexp (lit)
  (flet ((interpol (value)
           (mapcar (lambda (elem)
                     (if (stringp elem)
                         elem
                         (expr-to-sexp elem)))
                   value)))
    (ematch lit
      ((string-lit value)
       `(:string ,@(interpol value)))
      ((xstring-lit value)
       `(:xstring ,@(interpol value)))
      ((symbol-lit value)
       `(:symbol ,@(interpol value)))
      ((integer-lit value)
       `(:integer ,value))
      ((float-lit value)
       `(:float ,value))
      ((regexp-lit value)
       `(:regexp ,value)))))

(defun-ematch variable-to-sexp
  ((lvar name)  `(:lvar ,name))
  ((dvar name)  `(:dvar ,name))
  ((ivar name)  `(:ivar ,name))
  ((cvar name)  `(:cvar ,name))
  ((gvar name)  `(:gvar ,name))
  ((const path) `(:const ,(cpath-to-sexp path)))
  ((pvar name)  (pseudo-variable-to-sexp name)))

(defun-ematch cpath-to-sexp
  ((cpath-base name)     name)
  ((cpath-rel expr name) `(:colon2 ,(expr-to-sexp expr) ,name))
  ((cpath-abs path)      `(:colon3 ,(cpath-to-sexp path))))

(defun-ematch pseudo-variable-to-sexp
  (:nil      '(:nil))
  (:true     '(:true))
  (:alse     '(:false))
  (:self     '(:self))
  (:__FILE__ '(:string "<file>"))
  (:__LINE__ '(:integer 1)))

(defun-ematch parameter-to-sexp
  ((req-param name)      name)
  ((opt-param name init) `(:opt ,name ,(expr-to-sexp init)))
  ((rest-param name)     `(:rest ,name))
  ((star-param)          `(:star))
  ((block-param name)    `(:block ,name)))

(defun-ematch argument-to-sexp
  ((value-arg expr) (expr-to-sexp expr))
  ((splat-arg expr) `(:splat ,(expr-to-sexp expr)))
  ((block-arg expr) `(:block ,(expr-to-sexp expr)))
  ((hash-arg list)  `(:hash ,@(mapcar #'expr-to-sexp list))))

(defun-ematch lhs-to-sexp
  ((lhs-var var)
   (variable-to-sexp var))
  ((lhs-decl var)
   `(:decl ,(variable-to-sexp var)))
  ((lhs-dest list)
   `(:dest ,@(mapcar #'lhs-to-sexp list)))
  ((lhs-rest lhs)
   `(:rest ,(lhs-to-sexp lhs)))
  ((lhs-attr self name)
   `(:attr ,(expr-to-sexp self) ,name))
  ((lhs-aref self args)
   `(:aref ,(expr-to-sexp self) ,@(mapcar #'argument-to-sexp args)))
  ((lhs-op lhs name)
   `(:op ,(lhs-to-sexp lhs) ,name))
  ((lhs-or lhs)
   `(:or ,(lhs-to-sexp lhs)))
  ((lhs-and lhs)
   `(:and ,(lhs-to-sexp lhs))))

(defun-ematch1 block-to-sexp (block lhs body)
  `(:block ,(lhs-to-sexp lhs) ,(body-to-sexp body)))

(defun-ematch stmt-to-sexp
  ((alias-stmt new old)
   `(:alias ,new ,old))
  ((undef-stmt names)
   `(:undef ,@names))
  ((if-mod-stmt body test)
   `(:if-mod ,(expr-to-sexp test) ,(stmt-to-sexp body)))
  ((unless-mod-stmt body test)
   `(:unless-mod ,(expr-to-sexp test) ,(stmt-to-sexp body)))
  ((while-mod-stmt body test)
   `(:while-mod ,(body-stmt-to-sexp body) ,(expr-to-sexp test)))
  ((until-mod-stmt body test)
   `(:until-mod ,(stmt-to-sexp body) ,(expr-to-sexp test)))
  ((rescue-mod-stmt body else)
   `(:rescue-mod ,(stmt-to-sexp body) ,(stmt-to-sexp else)))
  ((pre-exec-stmt body)
   `(:pre-exec ,@(mapcar #'stmt-to-sexp body)))
  ((pre-exec-stmt body)
   `(:post-exec ,@(mapcar #'stmt-to-sexp body)))
  ((expr-stmt expr)
   (expr-to-sexp expr)))

(defun-ematch body-to-sexp
  ((list stmt) (stmt-to-sexp stmt))
  (list        `(:seq ,@(mapcar #'stmt-to-sexp list))))

(defun-ematch expr-to-sexp
  ((lit-expr lit)
   (literal-to-sexp lit))
  ((var-expr var)
   (variable-to-sexp var))
  ((nth-ref-expr index)
   `(:nth-ref ,index))
  ((back-ref-expr char)
   `(:back-ref ,char))
  ((array-expr args)
   `(:array ,@(mapcar #'argument-to-sexp args)))
  ((hash-expr args)
   `(:hash ,@(mapcar #'argument-to-sexp args)))
  ((dot2-expr lhs rhs)
   `(:dot2 ,(expr-to-sexp lhs) ,(expr-to-sexp rhs)))
  ((dot3-expr lhs rhs)
   `(:dot3 ,(expr-to-sexp lhs) ,(expr-to-sexp rhs)))
  ((not-expr test)
   `(:not ,(expr-to-sexp test)))
  ((and-expr lhs rhs)
   `(:and ,(expr-to-sexp lhs) ,(expr-to-sexp rhs)))
  ((or-expr lhs rhs)
   `(:or ,(expr-to-sexp lhs) ,(expr-to-sexp rhs)))
  ((defined-expr test)
   `(:defined ,(expr-to-sexp test)))
  ((ternary-expr test then else)
   `(:ternary ,(expr-to-sexp test) ,(expr-to-sexp then) ,(expr-to-sexp else)))
  ((if-expr test then else)
   `(:if ,(expr-to-sexp test) ,(expr-to-sexp then) ,(expr-to-sexp else)))
  ((unless-expr test then else)
   `(:unless ,(expr-to-sexp test) ,(expr-to-sexp then) ,(expr-to-sexp else)))
  ((while-expr test body)
   `(:while ,(expr-to-sexp test) ,(body-to-sexp body)))
  ((until-expr test body)
   `(:until ,(expr-to-sexp test) ,(body-to-sexp body)))
  ((for-expr lhs gen body)
   `(:for ,(lhs-to-sexp lhs) ,(expr-to-sexp gen) ,(body-to-sexp body)))
  ((case-expr test whens else)
   `(:case ,(and test (expr-to-sexp test))
      ,(mapcar (lambda-ematch1 (cons args body)
                 `(:when ,(mapcar #'argument-to-sexp args)
                    ,(body-to-sexp body)))
        whens)
      ,(body-to-sexp else)))
  ((break-expr args)
   `(:break ,@(mapcar #'argument-to-sexp args)))
  ((next-expr args)
   `(:next ,@(mapcar #'argument-to-sexp args)))
  ((redo-expr)
   '(:redo))
  ((retry-expr)
   '(:retry))
  ((call-expr self name args block)
   `(:call ,(and self (expr-to-sexp self))
           ,name
           ,(mapcar #'argument-to-sexp args)
           ,(and block (block-to-sexp block))))
  ((return-expr args)
   `(:return ,@(mapcar #'argument-to-sexp args)))
  ((yield-expr args)
   `(:yield ,@(mapcar #'argument-to-sexp args)))
  ((super-expr (args t) block)
   `(:super t ,(and block (block-to-sexp block))))
  ((super-expr args block)
   `(:super ,(argument-to-sexp args) ,(and block (block-to-sexp block))))
  ((assign-expr lhs rhs kind)
   `(:assign ,(lhs-to-sexp lhs) ,(expr-to-sexp rhs) ,kind))
  ((class-expr path super body)
   `(:class ,(cpath-to-sexp path)
            ,(and super (expr-to-sexp super))
            ,(body-stmt-to-sexp body)))
  ((sclass-expr expr body)
   `(:sclass ,(expr-to-sexp expr) ,(body-stmt-to-sexp body)))
  ((module-expr path body)
   `(:module ,(cpath-to-sexp path) ,(body-stmt-to-sexp body)))
  ((defn-expr name params body)
   `(:defn ,name ,(mapcar #'parameter-to-sexp params)
      ,(body-stmt-to-sexp body)))
  ((defs-expr expr name params body)
   `(:defs ,(expr-to-sexp expr) ,name ,(mapcar #'parameter-to-sexp params)
      ,(body-stmt-to-sexp body)))
  ((begin-expr body)
   `(:begin ,(body-stmt-to-sexp body)))
  ((seq-expr body)
   (body-to-sexp body)))

(defun-ematch1 body-stmt-to-sexp (body-stmt body rescues else ensure)
  `(:body ,(body-to-sexp body)
          ,(mapcar (lambda-ematch1 (cons args body)
                     `(:rescue ,(mapcar #'argument-to-sexp args)
                               ,@(body-to-sexp body)))
                   rescues)
          (:else ,@(body-to-sexp else))
          (:ensure ,@(body-to-sexp ensure))))

(defun ast-to-sexp (ast)
  (body-to-sexp ast))

;;; Export

(labels ((subclasses (class)
           (let ((direct-subclasses (closer-mop:class-direct-subclasses class)))
             (remove-duplicates (apply #'append direct-subclasses (mapcar #'subclasses direct-subclasses))))))
  (iter (with node = (find-class 'node))
        (for class in (cons node (subclasses node)))
        (for class-name = (class-name class))
        (for constructor = (symbolicate :make- class-name))
        (for predicate = (symbolicate class-name :-p))
        (export class-name)
        (export constructor)
        (export predicate)
        (iter (for slot in (closer-mop:class-direct-slots class))
              (for slot-name = (closer-mop:slot-definition-name slot))
              (for accessor = (symbolicate class-name :- slot-name))
              (export slot-name)
              (export accessor))))
