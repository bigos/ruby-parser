(in-package :ruby-parser)

(defstruct node loc)

;;; Literals

(defvariant (literal (:include node))
  (string-lit (value (proper-list string-content)))
  (xstring-lit (value (proper-list string-content)))
  (symbol-lit (value (proper-list string-content)))
  (integer-lit (value integer))
  (float-lit (value float))
  (regexp-lit (value (proper-list string-content))
              (flag regexp-flag :init-form nil)))

(deftype string-content ()
  '(or string expr))

(deftype regexp-flag ()
  '(member nil :once))

;;; Identifiers

(defvariant (identifier (:include node))
  (lvar (name string))
  (dvar (name string))
  (ivar (name string))
  (cvar (name string))
  (gvar (name string))
  (const (cpath cpath))
  (pvar (name pseudo-variable)))

(defvariant (cpath (:include node))
  (cpath-name (string string))
  (cpath-rel (base expr)
             (string string))
  (cpath-glob (cpath cpath)))

(deftype pseudo-variable ()
  '(member :nil :true :false :self :__FILE__ :__LINE__))

;;; Parameters

(defvariant (parameter (:include node))
  (param (name string))
  (opt-param (name string)
             (init expr))
  (rest-param (name string))
  (star-param)
  (block-param (name string)))

;;; Arguments

(defvariant (argument (:include node))
  (arg-value (expr expr))
  (arg-splat (expr expr))
  (arg-block (expr expr))
  (arg-hash (list (proper-list expr))))

;;; LHS

(defvariant (lhs (:include node))
  (lhs-id (id identifier))
  (lhs-decl (id identifier))
  (lhs-dest (list (proper-list lhs)))
  (lhs-rest (lhs lhs))
  (lhs-star)
  (lhs-attr (self expr)
            (meth string))
  (lhs-aref (self expr)
            (args (proper-list argument)))
  (lhs-op (lhs lhs)
          (op string))
  (lhs-or (lhs lhs))
  (lhs-and (lhs lhs)))

;;; Misc

(defstruct (blk (:include node))
  (vars (required-argument) :type (proper-list lhs))
  (body (required-argument) :type (proper-list stmt)))

(deftype assign-kind ()
  '(member :single :svalue :multi))

;;; Statements

(defvariant (stmt (:include node))
  (alias-stmt (new string)
              (old string))
  (undef-stmt (list (proper-list string)))
  (if-mod-stmt (stmt stmt)
               (test expr))
  (unless-mod-stmt (stmt stmt)
                   (test expr))
  (while-mod-stmt (stmt stmt)
                  (test expr))
  (until-mod-stmt (stmt stmt)
                  (test expr))
  (rescue-mod-stmt (stmt stmt)
                   (else stmt))
  (pre-exec-stmt (body (proper-list stmt)))
  (post-exec-stmt (body (proper-list stmt)))
  (expr-stmt (expr expr)))

;;; Expressions

(defvariant (expr (:include node))
  (lit-expr (lit literal))
  (id-expr (id identifier))
  (nth-ref-expr (n fixnum))
  (back-ref-expr (c character))
  (array-expr (args (proper-list argument)))
  (hash-expr (args (proper-list expr)))
  (dot2-expr (lhs expr)
             (rhs expr))
  (dot3-expr (lhs expr)
             (rhs expr))
  (not-expr (expr expr))
  (and-expr (lhs expr)
            (rhs expr))
  (or-expr (lhs expr)
           (rhs expr))
  (defined-expr (expr expr))
  (tern-expr (test expr)
             (then expr)
             (else expr))
  (if-expr (test expr)
           (then (proper-list stmt))
           (else (proper-list stmt)))
  (unless-expr (test expr)
               (then (proper-list stmt))
               (else (proper-list stmt)))
  (while-expr (test expr)
              (body (proper-list stmt)))
  (until-expr (test expr)
              (body (proper-list stmt)))
  (for-expr (lhs lhs)
            (gen expr)
            (body (proper-list stmt)))
  (case-expr (test (or null expr) :init-form nil)
             (whens (proper-list (cons (proper-list argument)
                                       (proper-list stmt))))
             (else (proper-list stmt)))
  (break-expr (args (proper-list argument) :init-form '()))
  (next-expr (args (proper-list argument) :init-form '()))
  (redo-expr)
  (retry-expr)
  (call-expr (recv (or null expr) :init-form nil)
             (meth string)
             (args (proper-list argument) :init-form '())
             (block (or null blk) :init-form nil))
  (return-expr (args (proper-list argument) :init-form '()))
  (yield-expr (args (proper-list argument) :init-form '()))
  (super-expr (args (proper-list argument) :init-form '())
              (block (or null blk) :init-form nil))
  (zsuper-expr (block (or null blk) :init-form nil))
  (assign-expr (lhs lhs)
               (rhs expr)
               (kind assign-kind))
  (body-stmt (body (proper-list stmt))
             (rescues (proper-list (cons (proper-list argument)
                                         (proper-list stmt))))
             (else (proper-list stmt))
             (ensure (proper-list stmt)))
  (class-expr (cpath cpath)
              (super (or null expr) :init-form nil)
              (body body-stmt))
  (sclass-expr (expr expr)
               (body body-stmt))
  (module-expr (cpath cpath)
               (body body-stmt))
  (defn-expr (name string)
             (params (proper-list parameter))
             (body body-stmt))
  (defs-expr (expr expr)
             (name string)
             (params (proper-list parameter))
             (body body-stmt))
  (begin-expr (body body-stmt))
  (block-expr (body (proper-list stmt))))

;;; Export

(labels ((subclasses (class)
           (let ((direct-subclasses (closer-mop:class-direct-subclasses class)))
             (remove-duplicates (apply #'append direct-subclasses (mapcar #'subclasses direct-subclasses)))))
         (ast-export (symbol)
           (import symbol :ruby-parser.ast)
           (export symbol :ruby-parser.ast)))
  (iter (for class in (subclasses (find-class 'node)))
        (for class-name = (class-name class))
        (for predicate = (symbolicate class-name :-p))
        (ast-export class-name)
        (ast-export predicate)
        (iter (for slot in (closer-mop:class-direct-slots class))
              (for slot-name = (closer-mop:slot-definition-name slot))
              (for accessor = (symbolicate class-name :- slot-name))
              (ast-export slot-name)
              (ast-export accessor))))
